#include <stdbool.h>
#include "platform.h"
//#include "player.h"
//#include "sprite.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"
#include "xintc.h"

#define LEFT_JOY 23
#define MIDDLE_JOY 27
#define RIGHT_JOY 29
#define DOWN_JOY 30
#define UP_JOY 15


#define GRAPHICS_MEM_OFF 0x2000000
#define TEXT_MEM_OFF 0x1000000

#define VGA_PERIPH_MEM_mWriteMemory(Address, Data) \
 	Xil_Out32(Address, (Xuint32)(Data))

static XIntc xintc;

#define PUT_TO_FSL(address, value) \
	do {                           \
		putfsl(address, 0);        \
		putfsl(value, 0);          \
	} while(0)

typedef struct Sprite Sprite;

struct Sprite {
    const Xuint32 *image;
    const Xuint32 width;
    const Xuint32 height;
};

static Xuint32 get_key() {
	return XIo_In32(XPAR_MY_PERIPHERAL_0_BASEADDR);
}
//
//static void handle_input() {
//    static bool jumping = false;
//
//    if (get_key() == UP_JOY && player.y == 240) {
//        jumping = true;
//        player.state = PLAYER_STATE_JUMPING;
//    }
//
//    if (get_key() == MIDDLE_JOY) {
//        player.state = PLAYER_STATE_DUCKING;
//        jumping = false;
//    }
//    else {
//        if (player.y == 240) {
//            player.state = PLAYER_STATE_RUNNING;
//        }
//        else {
//            player.state = PLAYER_STATE_JUMPING;
//        }
//    }
//
//    if (jumping) {
//        if (player.y > 480 / 2 - 100) {
//            player.y -= 5;
//        }
//        else {
//            jumping = false;
//        }
//    }
//
//    if (!jumping) {
//        if (player.y < 480 / 2) {
//            player.y += 5;
//        }
//        else if (player.state == PLAYER_STATE_JUMPING) {
//            player.state = PLAYER_STATE_RUNNING;
//        }
//    }
//}

static void clear_graphics_screen(Xuint32 BaseAddress)
{
	int i;
	for (i = 0; i < 9600*4; i++){
	    PUT_TO_FSL(i, 0xFFFFFFFF);
	}
}

static void clear_text_screen(Xuint32 BaseAddress)
{
   	int i;

    for (i = 0; i < 4800; i++)
    {
        VGA_PERIPH_MEM_mWriteMemory(BaseAddress + TEXT_MEM_OFF + i*4, 0x20);
    }
}
//
//static bool game_running = false;
//void vga_interrupt_handler(void *arg) {
//    (void)arg;
//
//    if (!game_running) {
//        return;
//    }
//
//    clear_player();
//
//    handle_input();
//
//    animate_player();
//
//    show_player();
//
//}
//
//static
//void init_interrupt_controller()
//{
//	XStatus Status;
//
//	XIo_Out32(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x54, 0x1E0); //init terminal counter on 524
//	XIo_Out32(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x58, 1);		//enable timer
//
//	//initialize interrupt controller
//	Status = XIntc_Initialize (&xintc, XPAR_INTC_0_DEVICE_ID);
//	if (Status != XST_SUCCESS)
//		xil_printf ("\r\nInterrupt controller initialization failure");
//	else
//		xil_printf("\r\nInterrupt controller initialized");
//
//	// Connect interrupt_handler
//	Status = XIntc_Connect (&xintc, 0, (XInterruptHandler) vga_interrupt_handler, (void *)0);
//
//	if (Status != XST_SUCCESS)
//		xil_printf ("\r\nRegistering MY_TIMER Interrupt Failed");
//	else
//		xil_printf("\r\nMY_TIMER Interrupt registered");
//
//	//Start the interrupt controller in real mode
//	Status = XIntc_Start(&xintc, XIN_REAL_MODE);
//
//	//Enable interrupt controller
//	XIntc_Enable (&xintc, 0);
//	microblaze_enable_interrupts();
//}

static void init_colors()
{
	/* Define colors */
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x10, 0xFF0000);	//color 0
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x14, 0xFF00FF);	//color 1
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x18, 0xFF00FF);	//color 2
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x1C, 0xFF00FF);	//color 3 siva
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x20, 0xFF00FF);	//color 4
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x24, 0xFF00FF);	//color 5
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x28, 0xFF00FF);	//color 6
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x2C, 0xFF00FF);	//color 7
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x30, 0xFF00FF);	//color 8
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x34, 0xFF00FF);	//color 9
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x38, 0xFF00FF);	//color 10 A
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x3C, 0xFF00FF);	//color 11 B
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x40, 0xFF00FF);	//color 12 C
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x44, 0xFF00FF);	//color 13 D
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x48, 0xFF00FF);	//color 14 E
	VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x4C, 0xFEFEFE);	//color 15 F
}

void show_sprite(const Sprite *sprite, Xuint32 x, Xuint32 y) {
	Xuint32 i;
	Xuint32 j;

    y -= sprite->height;

    for (i = 0; i < sprite->width; i++) {
        for (j = 0; j < sprite->height; j++) {
        	Xuint32 offset;

            const Xuint32 index = (y + j) * (640 / 8) + (x + i);
            const Xuint32 sprite_color = sprite->image[j * sprite->width + i];
            Xuint32 out_color = 0;
            for (offset = 28; offset >= 0; offset -= 4) {
            	Xuint8 nibble = (sprite_color >> offset) & 0xF;
//                if (nibble == 0xF) {
//                    nibble = (background[index] >> offset) & 0xF;
//                }

                out_color = (out_color << 4) | nibble;
            }

            PUT_TO_FSL(index, sprite_color);
        }
    }
}

static const Xuint32 player_running2[] = {
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xF0000000, 0x0000FFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xF0000000, 0x0000FFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00110000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00110000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000FFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x0000000F, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x000FFFFF,
    0xFF00FFFF, 0xFFFFFFF0, 0x00000FFF, 0xFFFFFFFF,
    0xFF00FFFF, 0xFFFFFFF0, 0x00000FFF, 0xFFFFFFFF,
    0xFF00FFFF, 0xFFFFF000, 0x00000FFF, 0xFFFFFFFF,
    0xFF000FFF, 0xFFF00000, 0x00000000, 0xFFFFFFFF,
    0xFF00000F, 0xF0000000, 0x00000FF0, 0xFFFFFFFF,
    0xFF00000F, 0xF0000000, 0x00000FF0, 0xFFFFFFFF,
    0xFF000000, 0x00000000, 0x00000FFF, 0xFFFFFFFF,
    0xFFF00000, 0x00000000, 0x00000FFF, 0xFFFFFFFF,
    0xFFFF0000, 0x00000000, 0x00000FFF, 0xFFFFFFFF,
    0xFFFF0000, 0x00000000, 0x0000FFFF, 0xFFFFFFFF,
    0xFFFFF000, 0x00000000, 0x0000FFFF, 0xFFFFFFFF,
    0xFFFFFFF0, 0x00000000, 0x000FFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000000, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0x00000000, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xF00FFFF0, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xF0FFFFFF, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xF000FFFF, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x0FFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0x000FFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
};

static Sprite running2 = {
    player_running2,
    4,
    32
};

int main() {
	int i;
	int j;

    init_platform();
    init_colors();

    VGA_PERIPH_MEM_mWriteMemory(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR + 0x04, 0b11); //display and text mode
	clear_text_screen(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR);
	clear_graphics_screen(XPAR_VGA_PERIPH_MEM_0_S_AXI_MEM0_BASEADDR);

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 32; j++) {
			const int x = 10;
			const int y = 10;
            const Xuint32 index = (y + j) * (640 / 8) + (x + i);
            PUT_TO_FSL(index, running2.sprite[j * 4 + i]);
		}
	}

//	init_interrupt_controller();

//    init_player(10, 240);
//    show_player();
//
//    while (get_key() != UP_JOY && get_key() != MIDDLE_JOY) {
//
//    }
//    game_running = true;
//    player.state = PLAYER_STATE_RUNNING;

    while (1) {

    }
}
